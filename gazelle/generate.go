// Copyright 2019 The Bazel Authors. All rights reserved.
// Modifications copyright (C) 2021 BenchSci Analytics Inc.
// Modifications copyright (C) 2018 Ecosia GmbH

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package js

import (
	"fmt"
	"io/ioutil"
	"log"
	"path"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

type imports struct {
	set map[string]bool
}

var noImports = imports{
	set: map[string]bool{},
}

var localRules = rule.LoadInfo{
	Name:    "@com_github_benchsci_rules_nodejs_gazelle//:defs.bzl",
	Symbols: []string{"web_asset", "web_assets", "js_library", "ts_definition"},
}
var tsRules = rule.LoadInfo{
	Name:    "@npm//@bazel/typescript:index.bzl",
	Symbols: []string{"ts_project"},
}
var jestRules = rule.LoadInfo{
	Name:    "@npm//jest:index.bzl",
	Symbols: []string{"jest_test"},
}
var managedRulesSet map[string]bool

func init() {
	managedRulesSet = make(map[string]bool)
	for _, rule := range localRules.Symbols {
		managedRulesSet[rule] = true
	}
	for _, rule := range tsRules.Symbols {
		managedRulesSet[rule] = true
	}
	for _, rule := range jestRules.Symbols {
		managedRulesSet[rule] = true
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (lang *JS) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		localRules,
		tsRules,
		jestRules,
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// A GenerateResult struct is returned. Optional fields may be added to this
// type in the future.
//
func (lang *JS) GenerateRules(args language.GenerateArgs) language.GenerateResult {

	jsConfigs := args.Config.Exts[languageName].(JsConfigs)
	jsConfig := jsConfigs[args.Rel]

	if !jsConfig.Enabled {
		// ignore this directory
		return language.GenerateResult{}
	}

	existingRules := make(map[string]*rule.Rule)

	// BUILD file exists?
	if BUILD := args.File; BUILD != nil {
		// For each existing rule
		for _, r := range BUILD.Rules {
			if _, ok := managedRulesSet[r.Kind()]; !ok {
				// not a managed rule
				continue
			}
			existingRules[r.Name()] = r
		}
	}

	pkgName := PkgName(args.Rel)

	managedFiles := make(map[string]bool)
	webAssetsSet := make(map[string]bool)

	tsSources := []string{}
	tsImports := []imports{}
	jsSources := []string{}
	jsImports := []imports{}

	generatedRules := make([]*rule.Rule, 0)
	generatedImports := make([]interface{}, 0)

	isModule := false

	absJSRoot, _ := filepath.Abs(jsConfig.JSRoot)
	isJSRoot := absJSRoot == args.Dir

	for _, baseName := range args.RegularFiles {
		managedFiles[baseName] = true

		filePath := path.Join(args.Dir, baseName)

		// TS DEFINITIONS ".d.ts"
		match := tsDefsExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			r := rule.NewRule(getKind(args.Config, "ts_definition"), strings.TrimSuffix(baseName, match[0])+".d")
			r.SetAttr("srcs", []string{baseName})
			if len(jsConfig.Visibility.Labels) > 0 {
				r.SetAttr("visibility", jsConfig.Visibility.Labels)
			}

			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, &noImports)
			continue
		}

		// TS & JS TEST
		match = append(jsTestExtensionsPattern.FindStringSubmatch(baseName), tsTestExtensionsPattern.FindStringSubmatch(baseName)...)
		if len(match) > 0 {
			i, r := lang.makeTestRule(testRuleArgs{
				ruleType:  getKind(args.Config, "jest_test"),
				extension: match[0],
				filePath:  filePath,
				baseName:  baseName,
			}, jsConfig)
			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, i)
			continue
		}

		// if the filename is like index.(jsx) then we assume we found a module
		if isModuleFile(baseName) {
			isModule = true
		}

		// TS
		match = tsExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			tsSources = append(tsSources, baseName)
			tsImports = append(tsImports, *readFileAndParse(filePath))
			continue
		}
		// JS
		match = jsExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			jsSources = append(jsSources, baseName)
			jsImports = append(jsImports, *readFileAndParse(filePath))
			continue
		}

		// WEB ASSETS
		for suffix := range jsConfig.WebAssetSuffixes {
			if strings.HasSuffix(baseName, suffix) {
				webAssetsSet[baseName] = true
				continue
			}
		}
		
	}

	if isModule && len(tsSources) > 0 && len(jsSources) > 0 {
		log.Print(Warn("[WARN] ts and js files mixed in module %s", pkgName))
	}

	aggregateModule := jsConfig.AggregateModules && isModule && !isJSRoot

	// add "ts_project" rule(s)
	genRules := func(kindSources []string, kindImports []imports, appendTS bool, kind string) {
		if len(kindSources) > 0 {
			name := pkgName
			if appendTS {
				name = name + ".ts"
			}
			if aggregateModule {
				// add as a module
				moduleImports, moduleRules := lang.makeModuleRules(moduleRuleArgs{
					pkgName:  name,
					cwd:      args.Rel,
					ruleType: getKind(args.Config, kind),
					srcs:     kindSources,
					imports:  kindImports,
				}, jsConfig)
				if !jsConfig.Quiet && len(moduleRules) > 1 {
					log.Print(Warn("[WARN] disjoint module %s", args.Rel))
				}
				for i := range moduleRules {
					generatedRules = append(generatedRules, moduleRules[i])
					generatedImports = append(generatedImports, moduleImports[i])
				}
			} else {
				// add as singletons
				singletonRules := lang.makeRules(ruleArgs{
					ruleType: getKind(args.Config, kind),
					srcs:     kindSources,
					trimExt:  true,
				}, jsConfig)
				for i := range singletonRules {
					generatedRules = append(generatedRules, singletonRules[i])
					generatedImports = append(generatedImports, &kindImports[i])
				}
			}
		}
	}

	// add ts_project rules
	genRules(tsSources, tsImports, len(jsSources) > 0, "ts_project")
	// add js_library rules
	genRules(jsSources, jsImports, false, "js_library")

	// read webAssetsSet to list
	webAssets := make([]string, 0, len(webAssetsSet))
	for fl := range webAssetsSet {
		webAssets = append(webAssets, fl)
	}
	if len(webAssets) > 0 {
		// Generate web_asset rule(s)

		if jsConfig.AggregateWebAssets {
			// aggregate rule
			name := "assets"
			r := rule.NewRule(getKind(args.Config, "web_assets"), name)
			r.SetAttr("srcs", webAssets)
			if len(jsConfig.Visibility.Labels) > 0 {
				r.SetAttr("visibility", jsConfig.Visibility.Labels)
			}

			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, &noImports)

			// record all webAssets rules for all_assets rule later
			fqName := fmt.Sprintf("//%s:%s", path.Join(args.Rel), name)
			jsConfig.AggregatedAssets[fqName] = true

		} else {
			// add as singletons
			rules := lang.makeRules(ruleArgs{
				ruleType: getKind(args.Config, "web_asset"),
				srcs:     webAssets,
				trimExt:  false, //shadow the original file name
			}, jsConfig)

			for _, r := range rules {
				generatedRules = append(generatedRules, r)
				generatedImports = append(generatedImports, &noImports)

				// record all webAssets rules for all_assets rule later
				fqName := fmt.Sprintf("//%s:%s", path.Join(args.Rel), r.Name())
				jsConfig.AggregatedAssets[fqName] = true
			}
		}
	}

	if isJSRoot && jsConfig.AggregateAllAssets {
		// Generate all_assets rule
		JSRootDeps := []string{}
		for fqName := range jsConfig.AggregatedAssets {
			JSRootDeps = append(JSRootDeps, fqName)
		}
		name := "all_assets"
		r := rule.NewRule(getKind(args.Config, "web_assets"), name)
		r.SetAttr("srcs", JSRootDeps)

		generatedRules = append(generatedRules, r)
		generatedImports = append(generatedImports, &noImports)
	}

	// Generate a list of rules that may be deleted
	// This is generated from existing rules that are managed by gazelle
	// that didn't get generated this run

	// Populate set with existing rules
	deleteRulesSet := make(map[string]*rule.Rule)
	for _, existingRule := range existingRules {
		// use kind/name to enable deletion of old rules when a new rule would use the same name
		key := fmt.Sprintf("%s/%s", existingRule.Kind(), existingRule.Name())
		deleteRulesSet[key] = existingRule
	}

	// Prune generated rules
	for _, generatedRule := range generatedRules {
		key := fmt.Sprintf("%s/%s", generatedRule.Kind(), generatedRule.Name())
		delete(deleteRulesSet, key)
	}

	for _, r := range deleteRulesSet {
		// Is this rule managed by Gazelle?
		if _, ok := managedRulesSet[r.Kind()]; ok {
			// It is managed, and wasn't generated, so delete it
			r.Delete()
		}
	}

	return language.GenerateResult{
		Gen:     generatedRules,
		Empty:   []*rule.Rule{},
		Imports: generatedImports,
	}
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (*JS) Fix(c *config.Config, f *rule.File) {
	
	jsConfigs := c.Exts[languageName].(JsConfigs)
	jsConfig := jsConfigs[f.Pkg]

	if c.ShouldFix || jsConfig.Fix {
		for _, r := range f.Rules {
			// delete deprecated js_import rule
			if r.Kind() == "js_import" {
				r.Delete()
			}
			// delete deprecated ts_library rule
			if r.Kind() == "ts_library" {
				r.Delete()
			}
		}
		for _, l := range f.Loads {

			if l.Has("js_import") {
				l.Remove("js_import")
			}
			if l.Has("ts_library") {
				l.Remove("ts_library")
			}
		}
	}
}

type testRuleArgs struct {
	ruleType  string
	extension string
	filePath  string
	baseName  string
}

func (lang *JS) makeTestRule(args testRuleArgs, jsConfig *JsConfig) (*imports, *rule.Rule) {
	imps := readFileAndParse(args.filePath)
	ruleName := strings.TrimSuffix(args.baseName, args.extension) + ".test"
	r := rule.NewRule(args.ruleType, ruleName)
	r.SetAttr("srcs", []string{args.baseName})
	if len(jsConfig.Visibility.Labels) > 0 {
		r.SetAttr("visibility", jsConfig.Visibility.Labels)
	}
	return imps, r
}

type moduleRuleArgs struct {
	pkgName  string
	cwd      string
	ruleType string
	srcs     []string
	imports  []imports
}

func (lang *JS) makeModuleRules(args moduleRuleArgs, jsConfig *JsConfig) ([]*imports, []*rule.Rule) {

	// identify the "index.js|ts" src file and include it in moduleSet
	// all other source files start in remainderSet
	indexKey := ""
	moduleSet := make(map[string]imports)
	remainderSet := make(map[string]imports)

	for i, src := range args.srcs {
		if isModuleFile(src) {
			moduleSet[src] = args.imports[i]
			indexKey = src
		} else {
			remainderSet[src] = args.imports[i]
		}
	}

	// recurse through each import for src file
	// which, if it's local, transitively belongs in the moduleSet
	recAddTransitiveSet := func(src string) {
		// for each import that the source file has
		for imp, _ := range moduleSet[src].set {
			// if that import is local to this directory
			if isLocalImport(args.cwd, imp) {
				// check the remainderSet to see if the src file corresponding to the import
				// exists and also hasn't been included in the module yet
				basename := path.Base(imp)
				for _, ext := range append(tsExtensions, jsExtensions...) {
					filename := basename + ext
					if _, ok := remainderSet[filename]; ok {
						// copy the src file out of the remainderSet and into the moduleSet
						moduleSet[filename] = remainderSet[filename]
						delete(remainderSet, filename)
						break
					}
				}
			}
		}
	}

	// start with index and recurse through imports
	recAddTransitiveSet(indexKey)

	// Accumulate Modules sources and imports into lists
	moduleSrcs := make([]string, 0)
	moduleImportsList := make([]imports, 0)
	for src, imports := range moduleSet {
		moduleSrcs = append(moduleSrcs, src)
		moduleImportsList = append(moduleImportsList, imports)
	}
	moduleImports := aggregateImports(moduleImportsList)

	// Use lists to make a rule
	moduleRule := rule.NewRule(args.ruleType, args.pkgName)
	moduleRule.SetAttr("srcs", moduleSrcs)
	if len(jsConfig.Visibility.Labels) > 0 {
		moduleRule.SetAttr("visibility", jsConfig.Visibility.Labels)
	}
	moduleRule.SetAttr("tags", []string{"js_module"})

	// Accumulate remainder srcs and imports into lists
	remainderSrcs := make([]string, 0)
	remainderImportsList := make([]imports, 0)
	for src, imps := range remainderSet {
		remainderSrcs = append(remainderSrcs, src)
		remainderImportsList = append(remainderImportsList, imps)
	}

	// Make remainder rules
	remainderRules := lang.makeRules(ruleArgs{
		ruleType: args.ruleType,
		srcs:     remainderSrcs,
		trimExt:  true,
	}, jsConfig)

	// Collate results
	allImports := []*imports{moduleImports}
	allRules := []*rule.Rule{moduleRule}

	for _, imp := range remainderImportsList {
		allImports = append(allImports, &imp) // Required to create references
	}
	allRules = append(allRules, remainderRules...)

	return allImports, allRules
}

type ruleArgs struct {
	ruleType string
	srcs     []string
	trimExt  bool
}

func (lang *JS) makeRules(args ruleArgs, jsConfig *JsConfig) []*rule.Rule {
	rules := []*rule.Rule{}
	for _, src := range args.srcs {
		var name string
		if args.trimExt {
			name = trimExt(src)
		} else {
			name = strings.ReplaceAll(src, ".", "_")
			if name == src {
				name += ".file"
			}
		}
		r := rule.NewRule(args.ruleType, name)
		r.SetAttr("srcs", []string{src})
		if len(jsConfig.Visibility.Labels) > 0 {
			r.SetAttr("visibility", jsConfig.Visibility.Labels)
		}
		rules = append(rules, r)
	}
	return rules
}

func readFileAndParse(filePath string) *imports {

	fileImports := imports{
		set: make(map[string]bool),
	}

	// If this file is a React component, always add react as dependency as the file could be using native
	// JSX transpilation from React package that doesn't need the "import React" statement
	if isReactFile(filePath) {
		fileImports.set["react"] = true 
	}

	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Fatalf(Err("Error reading %s: %v", filePath, err))
	}
	jsImports, err := ParseJS(data)
	if err != nil {
		log.Fatalf(Err("Error parsing %s: %v", filePath, err))
	}
	for _, imp := range jsImports {
		fileImports.set[imp] = true
	}

	return &fileImports
}

func isLocalImport(cwd string, path string) bool {

	// Special case for dot prefix without a folder
	if strings.HasPrefix(path, "./") {
		trimmed := strings.TrimPrefix(path, "./")
		return len(strings.Split(trimmed, "/")) == 1
	}

	// Compare both import path with cwd path
	// so "foo/bar/baz" matches "bar/baz/file.ts"
	cwdSegments := strings.Split(cwd, "/")
	importSegments := strings.Split(path, "/")
	for i := 0; i < len(importSegments)-1; i++ {
		j := len(importSegments) - i - 2 // ith deepest folder, minus file
		k := len(cwdSegments) - i - 1    // ith deepest folder
		if j < 0 || k < 0 || importSegments[j] != cwdSegments[k] {
			return false
		}
	}
	return true
}

func aggregateImports(imps []imports) *imports {

	aggregatedImports := imports{
		set: make(map[string]bool),
	}
	for i := range imps {
		for k, v := range imps[i].set {
			aggregatedImports.set[k] = v
		}
	}

	return &aggregatedImports
}

func getKind(c *config.Config, kind_name string) string {
	// Extract kind_name from KindMap
	if kind, ok := c.KindMap[kind_name]; ok {
		return kind.KindName

	}
	return kind_name
}
