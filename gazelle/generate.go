// Copyright 2019 The Bazel Authors. All rights reserved.
// Modifications copyright (C) 2021 BenchSci Analytics Inc.
// Modifications copyright (C) 2018 Ecosia GmbH

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package js

import (
	"fmt"
	"io/ioutil"
	"log"
	"path"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

type imports struct {
	set map[string]bool
}

var noImports = imports{
	set: map[string]bool{},
}

var localRules = rule.LoadInfo{
	Name:    "@com_github_benchsci_rules_nodejs_gazelle//:defs.bzl",
	Symbols: []string{"web_asset", "web_assets", "js_library", "ts_definition"},
}
var tsRules = rule.LoadInfo{
	Name:    "@npm//@bazel/typescript:index.bzl",
	Symbols: []string{"ts_project"},
}
var jestRules = rule.LoadInfo{
	Name:    "@npm//jest:index.bzl",
	Symbols: []string{"jest_test"},
}
var managedRulesSet map[string]bool

func init() {
	managedRulesSet = make(map[string]bool)
	for _, rule := range localRules.Symbols {
		managedRulesSet[rule] = true
	}
	for _, rule := range tsRules.Symbols {
		managedRulesSet[rule] = true
	}
	for _, rule := range jestRules.Symbols {
		managedRulesSet[rule] = true
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (lang *JS) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		localRules,
		tsRules,
		jestRules,
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// A GenerateResult struct is returned. Optional fields may be added to this
// type in the future.
//
func (lang *JS) GenerateRules(args language.GenerateArgs) language.GenerateResult {

	jsConfigs := args.Config.Exts[languageName].(JsConfigs)
	jsConfig := jsConfigs[args.Rel]

	if !jsConfig.Enabled {
		// ignore this directory
		return language.GenerateResult{}
	}

	existingRules := make(map[string]*rule.Rule)

	// BUILD file exists?
	if BUILD := args.File; BUILD != nil {
		// For each existing rule
		for _, r := range BUILD.Rules {
			if _, ok := managedRulesSet[r.Kind()]; !ok {
				// not a managed rule
				continue
			}
			existingRules[r.Name()] = r
		}
	}

	pkgName := PkgName(args.Rel)

	managedFiles := make(map[string]bool)
	webAssetsSet := make(map[string]bool)

	tsSources := []string{}
	tsImports := []imports{}
	jsSources := []string{}
	jsImports := []imports{}

	generatedRules := make([]*rule.Rule, 0)
	generatedImports := make([]interface{}, 0)

	isModule := false

	absJSRoot, _ := filepath.Abs(jsConfig.JSRoot)
	isJSRoot := absJSRoot == args.Dir

	for _, baseName := range args.RegularFiles {
		managedFiles[baseName] = true

		filePath := path.Join(args.Dir, baseName)

		// TS DEFINITIONS ".d.ts"
		match := tsDefsExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			r := rule.NewRule(getKind(args.Config, "ts_definition"), strings.TrimSuffix(baseName, match[0])+".d")
			r.SetAttr("srcs", []string{baseName})
			if len(jsConfig.Visibility.Labels) > 0 {
				r.SetAttr("visibility", jsConfig.Visibility.Labels)
			}

			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, &noImports)
			continue
		}

		// JS TEST
		match = jsTestExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			i, r := lang.makeTestRule(testRuleArgs{
				ruleType:  getKind(args.Config, "jest_test"),
				extension: match[0],
				filePath:  filePath,
				baseName:  baseName,
			}, jsConfig)
			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, i)
			continue
		}
		// TS TEST
		match = tsTestExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			i, r := lang.makeTestRule(testRuleArgs{
				ruleType:  getKind(args.Config, "jest_test"),
				extension: match[0],
				filePath:  filePath,
				baseName:  baseName,
			}, jsConfig)
			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, i)
			continue
		}

		// if the filename is like index.(jsx) then we assume we found a module
		if isModuleFile(baseName) {
			isModule = true
		}

		// TS
		match = tsExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			tsSources = append(tsSources, baseName)
			tsImports = append(tsImports, *readFileAndParse(filePath))
			continue
		}
		// JS
		match = jsExtensionsPattern.FindStringSubmatch(baseName)
		if len(match) > 0 {
			jsSources = append(jsSources, baseName)
			jsImports = append(jsImports, *readFileAndParse(filePath))
			continue
		}

		// WEB ASSETS
		for suffix := range jsConfig.WebAssetSuffixes {
			if strings.HasSuffix(baseName, suffix) {
				webAssetsSet[baseName] = true
				continue
			}
		}
	}

	if isModule && len(tsSources) > 0 && len(jsSources) > 0 {
		log.Print(Warn("[WARN] ts and js files mixed in module %s", pkgName))
	}

	aggregateModule := jsConfig.AggregateModules && isModule && !isJSRoot

	// add "ts_project" rule(s)
	if len(tsSources) > 0 {
		name := pkgName
		if len(jsSources) > 0 {
			name = name + ".ts"
		}
		if aggregateModule {
			// add as a module
			i, r := lang.makeModuleRule(moduleRuleArgs{
				ruleName: name,
				ruleType: getKind(args.Config, "ts_project"),
				srcs:     tsSources,
				imports:  tsImports,
			}, jsConfig)
			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, i)
		} else {
			// add as singletons
			tsRules := lang.makeRules(ruleArgs{
				ruleType: getKind(args.Config, "ts_project"),
				srcs:     tsSources,
				trimExt:  true,
			}, jsConfig)
			for i := range tsRules {
				generatedRules = append(generatedRules, tsRules[i])
				generatedImports = append(generatedImports, &tsImports[i])
			}
		}
	}

	// add "js_library" rule(s)
	if len(jsSources) > 0 {
		if aggregateModule {
			// add as a module
			i, r := lang.makeModuleRule(moduleRuleArgs{
				ruleName: pkgName,
				ruleType: getKind(args.Config, "js_library"),
				srcs:     jsSources,
				imports:  jsImports,
			}, jsConfig)
			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, i)
		} else {
			// add as singletons
			jsRules := lang.makeRules(ruleArgs{
				ruleType: getKind(args.Config, "js_library"),
				srcs:     jsSources,
				trimExt:  true,
			}, jsConfig)

			for i := range jsRules {
				generatedRules = append(generatedRules, jsRules[i])
				generatedImports = append(generatedImports, &jsImports[i])
			}
		}
	}

	// read webAssetsSet to list
	webAssets := make([]string, 0, len(webAssetsSet))
	for fl := range webAssetsSet {
		webAssets = append(webAssets, fl)
	}
	if len(webAssets) > 0 {
		// Generate web_asset rule(s)

		if jsConfig.AggregateWebAssets {
			// aggregate rule
			name := "assets"
			r := rule.NewRule(getKind(args.Config, "web_assets"), name)
			r.SetAttr("srcs", webAssets)
			if len(jsConfig.Visibility.Labels) > 0 {
				r.SetAttr("visibility", jsConfig.Visibility.Labels)
			}

			generatedRules = append(generatedRules, r)
			generatedImports = append(generatedImports, &noImports)

			// record all webAssets rules for all_assets rule later
			fqName := fmt.Sprintf("//%s:%s", path.Join(args.Rel), name)
			jsConfig.AggregatedAssets[fqName] = true

		} else {
			// add as singletons
			rules := lang.makeRules(ruleArgs{
				ruleType: getKind(args.Config, "web_asset"),
				srcs:     webAssets,
				trimExt:  false, //shadow the original file name
			}, jsConfig)

			for _, r := range rules {
				generatedRules = append(generatedRules, r)
				generatedImports = append(generatedImports, &noImports)

				// record all webAssets rules for all_assets rule later
				fqName := fmt.Sprintf("//%s:%s", path.Join(args.Rel), r.Name())
				jsConfig.AggregatedAssets[fqName] = true
			}
		}
	}

	if isJSRoot && jsConfig.AggregateAllAssets {
		// Generate all_assets rule
		JSRootDeps := []string{}
		for fqName := range jsConfig.AggregatedAssets {
			JSRootDeps = append(JSRootDeps, fqName)
		}
		name := "all_assets"
		r := rule.NewRule(getKind(args.Config, "web_assets"), name)
		r.SetAttr("srcs", JSRootDeps)

		generatedRules = append(generatedRules, r)
		generatedImports = append(generatedImports, &noImports)
	}

	// Generate a list of rules that may be deleted
	// This is generated from existing rules that are managed by gazelle
	// that didn't get generated this run
	deleteRulesSet := existingRules // no need to copy

	for _, generatedRule := range generatedRules {
		name := generatedRule.Name()
		// This is not an empty rule
		delete(deleteRulesSet, name)
	}

	for _, r := range deleteRulesSet {
		// Is this rule managed by Gazelle?
		if _, ok := managedRulesSet[r.Kind()]; ok {
			// It is managed, and wasn't generated, so delete it
			r.Delete()
		}
	}

	return language.GenerateResult{
		Gen:     generatedRules,
		Empty:   []*rule.Rule{},
		Imports: generatedImports,
	}
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (*JS) Fix(c *config.Config, f *rule.File) {

	jsConfigs := c.Exts[languageName].(JsConfigs)
	jsConfig := jsConfigs[f.Pkg]

	if c.ShouldFix || jsConfig.Fix {
		for _, r := range f.Rules {
			// delete deprecated js_import rule
			if r.Kind() == "js_import" {
				r.Delete()
			}
			// delete deprecated ts_library rule
			if r.Kind() == "ts_library" {
				r.Delete()
			}
		}
		for _, l := range f.Loads {

			if l.Has("js_import") {
				l.Remove("js_import")
			}
			if l.Has("ts_library") {
				l.Remove("ts_library")
			}
		}
	}
}

type testRuleArgs struct {
	ruleType  string
	extension string
	filePath  string
	baseName  string
}

func (lang *JS) makeTestRule(args testRuleArgs, jsConfig *JsConfig) (*imports, *rule.Rule) {
	imps := readFileAndParse(args.filePath)
	ruleName := strings.TrimSuffix(args.baseName, args.extension) + ".test"
	r := rule.NewRule(args.ruleType, ruleName)
	r.SetAttr("srcs", []string{args.baseName})
	if len(jsConfig.Visibility.Labels) > 0 {
		r.SetAttr("visibility", jsConfig.Visibility.Labels)
	}
	return imps, r
}

type moduleRuleArgs struct {
	ruleName string
	ruleType string
	srcs     []string
	imports  []imports
}

func (lang *JS) makeModuleRule(args moduleRuleArgs, jsConfig *JsConfig) (*imports, *rule.Rule) {
	imps := aggregateImports(args.imports)
	r := rule.NewRule(args.ruleType, args.ruleName)
	r.SetAttr("srcs", args.srcs)
	if len(jsConfig.Visibility.Labels) > 0 {
		r.SetAttr("visibility", jsConfig.Visibility.Labels)
	}
	r.SetAttr("tags", []string{"js_module"})
	return imps, r
}

type ruleArgs struct {
	ruleType string
	srcs     []string
	trimExt  bool
}

func (lang *JS) makeRules(args ruleArgs, jsConfig *JsConfig) []*rule.Rule {
	rules := []*rule.Rule{}
	for _, src := range args.srcs {
		var name string
		if args.trimExt {
			name = trimExt(src)
		} else {
			name = strings.ReplaceAll(src, ".", "_")
			if name == src {
				name += ".file"
			}
		}
		r := rule.NewRule(args.ruleType, name)
		r.SetAttr("srcs", []string{src})
		if len(jsConfig.Visibility.Labels) > 0 {
			r.SetAttr("visibility", jsConfig.Visibility.Labels)
		}
		rules = append(rules, r)
	}
	return rules
}

func readFileAndParse(filePath string) *imports {

	fileImports := imports{
		set: make(map[string]bool),
	}

	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Fatalf(Err("Error reading %s: %v", filePath, err))
	}
	jsImports, err := ParseJS(data)
	if err != nil {
		log.Fatalf(Err("Error parsing %s: %v", filePath, err))
	}
	for _, imp := range jsImports {
		fileImports.set[imp] = true
	}

	return &fileImports
}

func aggregateImports(imps []imports) *imports {

	aggregatedImports := imports{
		set: make(map[string]bool),
	}
	for i := range imps {
		for k, v := range imps[i].set {
			aggregatedImports.set[k] = v
		}
	}

	return &aggregatedImports
}

func getKind(c *config.Config, kind_name string) string {
	// Extract kind_name from KindMap
	if kind, ok := c.KindMap[kind_name]; ok {
		return kind.KindName

	}
	return kind_name
}
